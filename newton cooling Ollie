import numpy as np
import math
import matplotlib.pyplot as plt

#Constants for the number of iterations and how many graphs needed per number of iterations
number_of_iterations = 50000
number_of_graphs = 5
u = number_of_iterations//number_of_graphs

#Constants
number_of_points = int(101)
delta_x = 2/101
delta_t = 1/1000
alpha = 0.01
beta = 0.01
gamma = 0.01

# Newton cooling
h =1 #heat transfer coefficient
A =1 # heat transfer surface area
u_0 = 30 #environment Tem


r = alpha*delta_t/delta_x**2
r_1 = h*A*alpha*delta_t/delta_x

k = beta*delta_t

#Boundary conditions
left_boundary_condition = 800
right_boundary_condition = 800

#Boundary state for time equals zero and setting up the initial state
boundary_state = []
for s in range(0,number_of_points):
    boundary_state.append(0)
boundary_state[0] = left_boundary_condition
boundary_state[-1] = right_boundary_condition
boundary_state = tuple(boundary_state)


state = list(boundary_state)
print(state)
plots=[]

#Function which creates a new state and replaces the old one
def function_(l):
    new_state = []
    new_state.append(left_boundary_condition)
    for i in range(1,number_of_points-1):
        if i == (number_of_points-1)/2:
            new_state.append(r*state[i-1] + r*state[i+1] + (1-2*r)*state[i] + k*math.exp(gamma*state[i]))
        if i == (number_of_points):
            new_state.append(-2*r_1*(state[i]-u_0) + (1-2*r)*state[i] + 2*r*state[i-1] + k*math.exp(gamma*state[i]))
        else:
            new_state.append(r*state[i-1] + r*state[i+1] + (1-2*r)*state[i])
    new_state.append(right_boundary_condition)
    if l%u == 0:
        plots.append(new_state)
    for d in range(0,number_of_points):
        state[d] = new_state[d]
    return state

def function(l):
    new_state = []
    new_state.append(left_boundary_condition)
    for i in range(1,number_of_points-1):
        new_state.append(r*state[i-1] + r*state[i+1] + (1-2*r)*state[i] + k*math.exp(gamma*state[i]))
    #new_state.append(-2*r_1*(state[i]-u_0) + (1-2*r)*state[i] + 2*r*state[i-1] + k*math.exp(gamma*state[i]))
    new_state.append((-2*h*A*r*delta_x + 1 - 2*r)*state[i] + (2*r)*state[i-1] + (2*h*A*r*delta_x*u_0) + (k)*math.exp(gamma*state[i]))
    if l == 0:
        print(new_state)
    if l%u == 0:
        plots.append(new_state)
    for d in range(0,number_of_points):
        state[d] = new_state[d]
    return state
        

#Running the code for 'number_of_iterations' iterations
for l in range(0,number_of_iterations):
    function(l)

#Setting up the graph
x = np.linspace(-1,1,number_of_points)
for m in range(0,number_of_graphs):
    plt.plot(x,plots[m])
plt.show()
